/*
 * runAFC.cpp
 *
 *  Created on: 07-Jan-2022
 *      Author: amit
 */



#include "runAFC.h"


void runAFC(std::unique_ptr<MATLABEngine> &ep, user_inputs::ptr user, std::list<struct timeseries_input> initial_CE_values, intermediateResult::ptr intermediate) {
	//cout << "List of initial values are " << endl;
	/*for (unsigned int i=0; i< initial_CE_values.size(); i++) {
		cout << initial_CE_values[i] << " ,  ";
	}
	cout << endl;*/



// ***** Example to pass vector data to Matlab using MatlabEngine ******
	/*std::vector<double> cppData{ 4, 8, 12, 16, 20, 24 };
	size_t x=1, y=6;	//Must use size_t other data types did not worked
	// Create a x-by-y matlab data array
	matlab::data::ArrayFactory factory;
	auto inputArray = factory.createArray({ x, y }, cppData.cbegin(), cppData.cend());
	ep->setVariable(u"cp_data", inputArray); 	//This example puts the variable named data in the MATLAB base workspace.*/
// ***** Example to pass vector data to Matlab using MatlabEngine ******


	std::string cmd4;


	cmd4 = "time_step = ";
	cmd4.append(to_string(user->getSampleTime()));
	cmd4.append(";");
	ep->eval(convertUTF8StringToUTF16String(cmd4));

	std::list<struct timeseries_input>::iterator it_values = initial_CE_values.begin();

//	list<vector<double>> var_control_points = initial_CE_values.var_values;
//	list<vector<double>> time_for_cp = initial_CE_values.time_values;
//
//
//	// *** Because we know that the AFC model has first two variables as input variables ***
	//Todo: May be we can check the variable name before accessing var_values and time_values
//	list<vector<double>>::iterator it = var_control_points.begin();
//	list<vector<double>>::iterator it_time = time_for_cp.begin();

	//cout << "Time-Horizon and time-step Done " << endl;

	std::vector<double> cppData = (*it_values).var_values;
	size_t x=1, y=cppData.size();
	matlab::data::ArrayFactory factory;
	auto inputArray = factory.createArray({ x, y }, cppData.cbegin(), cppData.cend());
	ep->setVariable(u"cp_pedal_angle", inputArray);

	std::vector<double> cppTime = (*it_values).time_values;
	//std::cout <<"Last time of the input variable (cp_pedal_angle) = " << cppTime[cppTime.size()-1] <<endl;
	double time_horizon_dReach_CE = cppTime[cppTime.size()-1];
	assert(y == cppTime.size());
	matlab::data::ArrayFactory factory1;
	auto inputArray1 = factory1.createArray({ x, y }, cppTime.cbegin(), cppTime.cend());
	ep->setVariable(u"timeVector_pedal_angle", inputArray1);


	cmd4 = "time_horizon = ";
	//cmd4.append(to_string(user->getTimeHorizon()));		//Here can I extract the time-horizon of the CE-trace obtained from the Model-checker?
	cmd4.append(to_string(time_horizon_dReach_CE));
	cmd4.append(";");
	ep->eval(convertUTF8StringToUTF16String(cmd4));

	std::cout <<"Time-Horizon obtained from the Model-Checker = " << time_horizon_dReach_CE <<endl;

	it_values++;
	cppData = (*it_values).var_values;
	size_t y2=cppData.size();
	matlab::data::ArrayFactory factory2;
	auto inputArray2 = factory2.createArray({ x, y2 }, cppData.cbegin(), cppData.cend());
	ep->setVariable(u"cp_engine_speed", inputArray2);

	cppTime = (*it_values).time_values;
	std::cout <<"Last time of the input variable (cp_engine_speed) = " << cppTime[cppTime.size()-1] <<endl;
	//y2=cppTime.size();
	assert(y2 == cppTime.size());
	matlab::data::ArrayFactory factory3;
	auto inputArray3 = factory3.createArray({ x, y2 }, cppTime.cbegin(), cppTime.cend());
	ep->setVariable(u"timeVector_engine_speed", inputArray3);
	//cout << "Pedal-angle and engine-speed Done " << endl;

// **** End of Input Signal Generation ****

	//cout << "Pedal-angle and engine-speed Done " << endl;
	/*
		cmd4 = "x0_0 = ";
		cmd4.append(to_string(initial_CE_values[0]));
		cmd4.append(";");
		ep->eval(convertUTF8StringToUTF16String(cmd4));

		cmd4 = "x1_0 = ";
		cmd4.append(to_string(initial_CE_values[1]));
		cmd4.append(";");
		ep->eval(convertUTF8StringToUTF16String(cmd4));
	*/

	//exit(0);



	unsigned int execution_count = user->getNumberMatlabSimulationExecuted();
	std::string cmd = "cd ";
	std::string cmd2=" && rm result.txt";
	std::string pathOriginalModel_str="";


	//std::cout<<"cmd = "<< cmd <<std::endl;
	pathOriginalModel_str = intermediate->getMatlabPathForOriginalModel();
	//std::cout <<"tmp_str=" << pathOriginalModel_str <<std::endl;
	cmd.append(pathOriginalModel_str);
	cmd.append(cmd2);
	//std::cout << "cmd = " << cmd << std::endl;

	//Removing the files generated by Matlab in the previous run
	if (execution_count == 0) {	//running for the first time

		int x = system(cmd.c_str());
		if (x == -1) {
			std::cout <<"Error executing cmd: " << cmd <<std::endl;
		}
		//system("cd ../src/benchmark/nav_inst1 && rm result.tsv");	//most important file is result.tsv others I may see later if need arise
		cmd="addpath (genpath('";
		cmd.append(pathOriginalModel_str);
		cmd.append("'))");
		//engEvalString(ep, "addpath (genpath('../src/benchmark/nav_inst1'))"); //Since tool BBC4CPS will be executed from Release or Debug
		ep->eval(convertUTF8StringToUTF16String(cmd));
	}

	cmd="cd('";
	cmd.append(pathOriginalModel_str);
	cmd.append("')");
	//engEvalString(ep, "cd('../src/benchmark/nav_inst1')");
	ep->eval(convertUTF8StringToUTF16String(cmd));

	//ep->eval(convertUTF8StringToUTF16String("run_oscillator"));
	ep->eval(u"run_AFC");


	//This code can be used for other Models also.
	/*engEvalString(ep, "plot(x1,x2);");
	engEvalString(ep, "title('x1 vs. x2 of the Plot');");
	engEvalString(ep, "xlabel('x1');");
	engEvalString(ep, "ylabel('x2');");*/

	std::cout << "Done Calling Matlab's AFC Simulink (simulation)\n" << std::endl;

}
