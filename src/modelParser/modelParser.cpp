/*
 * modelParser.cpp
 *
 *  Created on: 22-Sep-2021
 *      Author: amit
 */

#include "../modelParser/modelParser.h"
#include "../dReachModelling/modelConstructor.h"


//using namespace boost::algorithm;
using namespace std;

// Implementing model parsing when the learning algorithm implements One-Versus-One approach
void modelParser_OneVersusOne(hybridAutomata::ptr &H, user_inputs::ptr &user, intermediateResult::ptr &intermediate) {
	//This function has common code for parsing ODE, with the function modelParser()

	//	extern  unsigned int log_set;
	//	std::ofstream log_file("bbc4cps_log_file.txt",  std::ios_base::binary | std::ios_base::app);

//		cout << "intermediate->getToolRootPath() = "<<intermediate->getToolRootPath() <<endl;

		//******** Temporary Fix: copying the file generated by learning algorithm to the current directory **********
		string copycommand ="";
		copycommand.append("cp ");
		copycommand.append(intermediate->getToolRootPath());
		copycommand.append("/src/pwa/");
		copycommand.append(user->getOutputFilename());
		copycommand.append(" .");	//to the current working directory, i.e. in the Release directory
		int x = system(copycommand.c_str());
		if (x == -1) {
			cout << "Error executing cmd: " << copycommand << endl;
		}
		//******** modelfile now in the current directory **********
		/*
		 * Note:
		 * This modelfile has a specific format generated by the learning algorithm. The syntax and format is as follows:
		 * First line contains File-parameter-information (number-of-modes, number-of-dimension and number-of-transitions)
		 * ---------------------------------------------------------------------------
		 * The SECOND line has the initial starting location-ID as:
		 * Initial-mode 1
		 * ---------------------------------------------------------------------------
		 * Third line onwards contains the mode number-1
		 * Forth line contains the ODE for this mode for the first variable
		 * Fifth line the ODE for the 2nd variable (assume number-of-dimension=2)
		 * ---------------------------------------------------------------------------
		 * Sixth line contains the mode number-2
		 * Seventh line contains the ODE for this mode for the first variable
		 * Eighth line the ODE for the 2nd variable (assume number-of-dimension=2)
		 * ---------------------------------------------------------------------------
		 * Ninth line contain the Transition-Guard number-1
		 * Tenth line contain the polynomial-guard constraints (assume number-of-modes=2)
		 *
		 *
		 *
		 *
		 *
		 *
		 * So, for 2-modes there is just one Transition-Guard learned by Naijun's implementation
		 * *************************** (When the learning approach is ONE-VERSUS-ONE): ***************************
		 * If number of modes(m) and m >= 3, then total number of transitions K = m * (m -1)/ 2. The format is as below
		 * Tenth line will contain Transition-Src-Dest	"src-id  =>  dest-id" Example:
		 * Transition-Src-Dest	1  =>  2
		 * Eleventh line will contain the polynomial-guard constraints
		 * ----------------------------------
		 * Twelfth line contain the Transition-Guard number-2
		 * Thirteenth line contain  Transition-Src-Dest	"src-id  =>  dest-id" Example:
		 * Transition-Src-Dest	1  =>  3
		 * Fourteenth line contain the polynomial-guard constraints (assume number-of-modes=3)
		 * ----------------------------------
		 * Fifteenth line contain the Transition-Guard number-3
		 * Sixteenth line contain  Transition-Src-Dest	"src-id  =>  dest-id" Example:
		 * Transition-Src-Dest	2  =>  3
		 * Seventeenth line contain the polynomial-guard constraints (assume number-of-modes=3)
		 * */

		const char* modelfile = user->getOutputFilename().c_str();		//This is the optimized fileName
		std::ifstream in(modelfile);//This is the file generated by running the Learning Algorithm
		unsigned int tot_modes, tot_dimension, tot_transitions, tot_trans_oneVsone;

		if (in) {
			std::string line1;
			std::getline(in, line1); //Reading First Line: Each getline() function will read a line and moves the pointer to the beginning of the next line
			std::istringstream row1(line1);
			//cout<<"Line is "<< line1<<endl;
			row1 >> tot_modes; //Reading First value the number-of-modes
			row1 >> tot_dimension; //Reading Second value the number-of-dimension
			row1 >> tot_transitions; //Reading Third value the number-of-transition-guard
			tot_trans_oneVsone = tot_modes * (tot_modes - 1) / 2;	//Formula for number of transition, when SVM uses One-Versus-One approach
			assert(tot_trans_oneVsone == tot_transitions);
			//cout << "tot_modes = "<<tot_modes<<"  tot_dim="<<tot_dimension <<"   tot_trans="<<tot_transitions <<endl;

			//Shifting the code for Initial Location-ID from the last line to the SECOND line.
			//Reading and setting the Initial ID
			std::getline(in, line1);	//This read is for reading the Initial-Location-ID
			std::istringstream row22(line1);
			//cout<<"Transition Line is "<< line1<<endl;
			string init_label;
			unsigned int init_id;
			row22 >> init_label; //Reading First word of the line1 i.e., the word "Initial-mode"
			row22 >> init_id; //Reading the next word/value i.e., the Initial-Location-ID "1" (say)
			H->setInitialId(init_id);

			//cout <<"Initial Location-ID=" << init_id <<endl;

			std::map<int, location::ptr> map_location_list1, map_location_list2; //mapping of the key loc_id to location::ptr
			//std::map<std::string, int> loc_name_map_id; //here name is used as a Key for ease of search
			//int loc_counter = 1; //loc-Id for key to map_loc_list
			//Reading All Mode's ODE
			for (unsigned int i = 1; i <= tot_modes; i++) {	//Modes starts from 1
				location::ptr loc = location::ptr(new location());
				string label_modes;
				int mode_number;

				getline(in , line1);	//This read for reading the mode number
				std::istringstream row1(line1);
				//cout<<"Line is "<< line1<<endl;
				row1 >> label_modes; //Reading First word of the line1 i.e., the word "mode"
				row1 >> mode_number; //Reading the next word/value i.e., the mode-number "1" (say)
				string mode_name = "mode"+ to_string(mode_number);
				loc->setLocId(mode_number);
				loc->setName(mode_name);
				list<flow_equation> derivatives;

				for (unsigned int j = 0; j < tot_dimension; j++) {
					flow_equation ODEperVariable;
					string LHS, RHS;
					getline(in , line1);	//This read for reading the ODE for each dimension
					ODEperVariable.derivative = line1;
					std::istringstream lhsWord(line1);
					lhsWord >> ODEperVariable.varName; //Note it include the derivative symbol (')

					size_t found = line1.find("=");
					if (found != string::npos) {
						//cout << "First occurrence is " << found << endl;
						//RHS = line1.substr (found+1);
						//ODEperVariable.RHSexpression = boost::trim_left(RHS);	//can think about constant dynamics later
						RHS = line1.substr (found+2); //Also left triming a white space
						ODEperVariable.RHSexpression = RHS;	//can think about constant dynamics later
						//cout << RHS << endl;
					} else {
						cout << "Invalid ODE equation found! " << endl;
						throw(new exception());
					}
					derivatives.push_back(ODEperVariable);
				}
				loc->setDerivatives(derivatives);	//First add all the modes without transition and later update the transition.
				map_location_list1[loc->getLocId()] = loc;
				//H->addLocation(loc);
			}
			H->addMapped_Locations_List(map_location_list1);

			location::ptr my_location = location::ptr(new location());
			//my_location = map_location_list1[loc_id];	//accessing from the map data structure to create a new location with same ID and name
			//and fill up the remaining details and replace the hybrid_automata with this new detailed location



			double epsilon= user->getPrecisionGuardRange();

			//Reading All Transition-Guard:
			//std::vector<transition::ptr> forward(2);	//for mode m==3, we have 3 transitions, K = m * (m - 1)/2
			std::vector<transition::ptr> forward(tot_trans_oneVsone);	//for mode==3, we have THREE transitions, considering the above formula due to One-Versus-One approach
			std::vector<transition::ptr> backward(tot_trans_oneVsone);
			unsigned int new_transition_Id = 1;
			unsigned int transition_count=0, trans_back_count=0; //for the extra transition
			for (unsigned int i = 1; i <= tot_transitions; i++) {
				string label, label_symbol, label_extra;
				int transition_id;



				if (tot_modes > 1) {
					/*
					 Steps for handling Transitions:
					 (1) Read all transition from the learned model-file.
					 (2) Store these (3) transitions as forward[0], forward[1], and forward[2]
					 (3) Now, create backward transitions as backward[0], backward[1], and backward[2]
					 (4) Now, sequentially read the forward and backward transitions and push them to the corresponding modes.
					 * */
					std::getline(in, line1);	//This read for reading the Transition-Guard-number
					std::istringstream row1(line1);
					//cout<<"Transition Line is "<< line1<<endl;

					row1 >> label; //Reading First word of the line1 i.e., the word "Transition-Guard"
					row1 >> transition_id; //Reading the next word/value i.e., the transition-number "1" (say)
					transition::ptr trans = transition::ptr(new transition()) ;
					//transition::ptr trans2 = transition::ptr(new transition()) ;

					trans->setTransId(transition_id);	//Note transition-id may start with 0, which does not have issue with dReach
					trans->setLabel(label);

					unsigned int src, dest;
					std::getline(in, line1);	//This read for reading the Src => Dest
					//cout <<"Trans Line="<<line1<<endl;
					std::istringstream row2(line1);
					row2 >> label_extra; //Reading First word of the line1 i.e., the word "Transition-Src-Dest"
					//cout<<"Transition Src-Dest Label is "<< label<<endl;
					row2 >> src; //Reading the next word/value i.e., the Src-mode-id "1" (say)
					//cout<<"Src = "<<src<<endl;
					row2 >> label_symbol; //Reading First word of the line1 i.e., the word " => "
					//cout<<"Transition Arrow Label is "<< label<<endl;
					row2 >> dest; //Reading the next word/value i.e., the Dest-mode-id "2".
					//cout<<"Dest-1 = "<<dest<<endl;


					trans->setSourceLocationId(src);
					trans->setDestinationLocationId(dest);
					//cout<<"Transition Src "<< trans->getSourceLocationId()<<endl;
					//cout<<"Transition Dest "<< trans->getDestinationLocationId()<<endl;

					std::list<std::string> guard;
					std::getline(in, line1);	//This read for reading the polynomial-guard constraints
					guard.push_back(line1);
					//cout<<"Transition Guard line1 is "<< line1<<endl;
					trans->setGuard(guard);

					// ************* Working for the Modified Guard to support inequality *************
					std::list<std::string> guard_modified;
					guard_modified = modify_guard_asRange(guard, epsilon);		//converting to range as inequality
					trans->setGuardModified(guard_modified);
					// ************* *************
					forward[transition_count] = trans;



					// For SNDS (switched nonlinear dynamical systems) transition are bi-directional since the state space is divided into two parts
					transition::ptr back_trans = transition::ptr(new transition());
					//*********** Creating Backward transitions ******************************

					unsigned int id = tot_transitions + new_transition_Id;	//Giving new transition-Id
					back_trans->setTransId(id);	//Note transition-id may start with 0, which does not have issue with dReach
					std::string back_trans_label = trans->getLabel();
					back_trans_label.append("-back");
					back_trans->setLabel(back_trans_label);
					new_transition_Id++;

					back_trans->setSourceLocationId(dest);
					back_trans->setDestinationLocationId(src);
					back_trans->setGuard(guard);

					// ************* Working for the Modified Guard to support inequality *************
					back_trans->setGuardModified(guard_modified);
					// ************* *************
					backward[trans_back_count] = back_trans;	//vector indexing from 0 for C++

					transition_count++;
					trans_back_count++;
					//*********** forward and backward transitions creation done ******************************
				} //When mode>1

			} //End of reading all transitions

			if (tot_modes > 1) {

				std::map<int, location::ptr> list_locations;
				list_locations = H->getLocation_List();

				//Iterate through all the modes get the mode-id and create list-of-Transitions and add as outGoingTransitions
				for (std::map<int, location::ptr>::iterator i= list_locations.begin(); i != list_locations.end(); i++) {
					location::ptr loc = (*i).second;	//since our location starts from 0
					//cout<<"Location Name: "<<loc->getName() <<"  ID: "<< loc->getLocId()<<endl;
					unsigned int src = loc->getLocId();
					list<transition::ptr> trans = getAllTrans(src, forward, backward);

					my_location = map_location_list1[src];	//i here is the mode-id
					my_location->setOutGoingTransitions(trans);	//the location is not updated with out-going-transition
					map_location_list2[src] = my_location;

				}
				//cout<<"back_trans_ created="<<endl;
			}

			if (tot_modes > 1) { //Modification of Transition is required only for modes > 1
				//cout<<"Total number of Locations (2) ="<<H->getTotalLocations() <<endl;
				H->addMapped_Locations_List(map_location_list2);	//This line is important to update the transitions
			}


		} //closing in file read-access
}

// Implementing model parsing when the learning algorithm implements One-Versus-Rest approach
void modelParser(hybridAutomata::ptr &H, user_inputs::ptr &user, intermediateResult::ptr &intermediate) {

//	extern  unsigned int log_set;
//	std::ofstream log_file("bbc4cps_log_file.txt",  std::ios_base::binary | std::ios_base::app);

	cout << "intermediate->getToolRootPath() = "<<intermediate->getToolRootPath() <<endl;

	//******** Temporary Fix: copying the file generated by learning algorithm to the current directory **********
	string copycommand ="";
	copycommand.append("cp ");
	copycommand.append(intermediate->getToolRootPath());
	copycommand.append("/src/pwa/");
	copycommand.append(user->getOutputFilename());
	copycommand.append(" .");	//to the current working directory, i.e. in the Release directory
	int x = system(copycommand.c_str());
	if (x == -1) {
		cout << "Error executing cmd: " << copycommand << endl;
	}
	//******** modelfile now in the current directory **********
	/*
	 * Note:
	 * This modelfile has a specific format generated by the learning algorithm. The syntax and format is as follows:
	 * First line contains File-parameter-information (number-of-modes, number-of-dimension and number-of-transitions)
	 * ---------------------------------------------------------------------------
	 * The SECOND line has the initial starting location-ID as:
	 * Initial-mode 1
	 * ---------------------------------------------------------------------------
	 * Third line onwards contains the mode number-1
	 * Forth line contains the ODE for this mode for the first variable
	 * Fifth line the ODE for the 2nd variable (assume number-of-dimension=2)
	 * ---------------------------------------------------------------------------
	 * Sixth line contains the mode number-2
	 * Seventh line contains the ODE for this mode for the first variable
	 * Eighth line the ODE for the 2nd variable (assume number-of-dimension=2)
	 * ---------------------------------------------------------------------------
	 * Ninth line contain the Transition-Guard number-1
	 * Tenth line contain the polynomial-guard constraints (assume number-of-modes=2)
	 *
	 * So, for 2-modes there is just one Transition-Guard learned by Naijun's implementation
	 * *********************************************
	 * If modes==3, the lines about Modes remains but Transitions one extra line will be added as below (When the learning approach is ONE-VERSUS-REST):
	 * Tenth line will contain Transition-Src-Dest	"src-id  =>  dest-id" Example:
	 * Transition-Src-Dest	0  =>  1,2
	 * Eleventh line will contain the polynomial-guard constraints
	 * ----------------------------------
	 * Twelfth line contain the Transition-Guard number-2
	 * Thirteenth line contain  Transition-Src-Dest	"src-id  =>  dest-id"
	 * Fourteenth line contain the polynomial-guard constraints (assume number-of-modes=3)
	 * ----------------------------------
	 *
	 * */

	const char* modelfile = user->getOutputFilename().c_str();		//This is the optimized fileName
	std::ifstream in(modelfile);//This is the file generated by running the Learning Algorithm
	int tot_modes, tot_dimension, tot_transitions;

	if (in) {
		std::string line1;
		std::getline(in, line1); //Reading First Line: Each getline() function will read a line and moves the pointer to the beginning of the next line
		std::istringstream row1(line1);
		//cout<<"Line is "<< line1<<endl;
		row1 >> tot_modes; //Reading First value the number-of-modes
		row1 >> tot_dimension; //Reading Second value the number-of-dimension
		row1 >> tot_transitions; //Reading Third value the number-of-transition-guard
		assert(tot_modes == (tot_transitions + 1));
		//cout << "tot_modes = "<<tot_modes<<"  tot_dim="<<tot_dimension <<"   tot_trans="<<tot_transitions <<endl;
//		if (log_set){
//			log_file << "tot_modes = "<<tot_modes<<"  tot_dim="<<tot_dimension <<"   tot_trans="<<tot_transitions <<endl;
//		}

		//Shifting the code for Initial Location-ID from the last line to the SECOND line.
		//Reading and setting the Initial ID
		std::getline(in, line1);	//This read is for reading the Initial-Location-ID
		std::istringstream row22(line1);
		//cout<<"Transition Line is "<< line1<<endl;
		string init_label;
		unsigned int init_id;
		row22 >> init_label; //Reading First word of the line1 i.e., the word "Initial-mode"
		row22 >> init_id; //Reading the next word/value i.e., the Initial-Location-ID "1" (say)
		H->setInitialId(init_id);

		//cout <<"Initial Location-ID=" << init_id <<endl;

		std::map<int, location::ptr> map_location_list1, map_location_list2; //mapping of the key loc_id to location::ptr
		//std::map<std::string, int> loc_name_map_id; //here name is used as a Key for ease of search
		//int loc_counter = 1; //loc-Id for key to map_loc_list
		//Reading All Mode's ODE
		for (int i = 1; i <= tot_modes; i++) {	//Modes starts from 1
			location::ptr loc = location::ptr(new location());
			string label_modes;
			int mode_number;

			getline(in , line1);	//This read for reading the mode number
			std::istringstream row1(line1);
			//cout<<"Line is "<< line1<<endl;
			row1 >> label_modes; //Reading First word of the line1 i.e., the word "mode"
			row1 >> mode_number; //Reading the next word/value i.e., the mode-number "1" (say)
			string mode_name = "mode"+ to_string(mode_number);
			loc->setLocId(mode_number);
			loc->setName(mode_name);
			list<flow_equation> derivatives;

			for (int j = 0; j < tot_dimension; j++) {
				flow_equation ODEperVariable;
				string LHS, RHS;
				getline(in , line1);	//This read for reading the ODE for each dimension
				ODEperVariable.derivative = line1;
				std::istringstream lhsWord(line1);
				lhsWord >> ODEperVariable.varName; //Note it include the derivative symbol (')

				size_t found = line1.find("=");
				if (found != string::npos) {
					//cout << "First occurrence is " << found << endl;
					//RHS = line1.substr (found+1);
					//ODEperVariable.RHSexpression = boost::trim_left(RHS);	//can think about constant dynamics later
					RHS = line1.substr (found+2); //Also left triming a white space
					ODEperVariable.RHSexpression = RHS;	//can think about constant dynamics later
					//cout << RHS << endl;
				} else {
					cout << "Invalid ODE equation found! " << endl;
//					if (log_set){
//						log_file << "Invalid ODE equation found! " << endl;
//					}
					throw(new exception());
				}
				derivatives.push_back(ODEperVariable);
			}
			loc->setDerivatives(derivatives);	//First add all the modes without transition and later update the transition.
			map_location_list1[loc->getLocId()] = loc;
			//H->addLocation(loc);
		}
		H->addMapped_Locations_List(map_location_list1);

		location::ptr my_location = location::ptr(new location());
		//my_location = map_location_list1[loc_id];	//accessing from the map data structure to create a new location with same ID and name
		//and fill up the remaining details and replace the hybrid_automata with this new detailed location







		double epsilon= user->getPrecisionGuardRange();

		//Reading All Transition-Guard:    Note: "Transition's Guard modified-inequality sign will depend on the initial-location"
		//std::vector<transition::ptr> forward(2);	//for mode==3, we have two transitions
		std::vector<transition::ptr> forward(3);	//for mode==3, we have THREE transitions, considering the class {1} ==> {2,3} as two transitions
		std::vector<transition::ptr> backward(3);
		unsigned int new_transition_Id = 1;
		unsigned int dest2, transition_count=0, trans_back_count=0; //for the extra transition
		for (int i = 1; i <= tot_transitions; i++) {
			string label, label_symbol, label_extra;
			int transition_id;

			if (tot_modes==2) {
				/*
				 * Note: The output-file which is being parsed has the format as described above.
				 * Moreover, the Mode-ID starts from 1.
				 */
				std::getline(in, line1);	//This read for reading the Transition-Guard-number
				std::istringstream row1(line1);
				//cout<<"Transition Line is "<< line1<<endl;

				row1 >> label; //Reading First word of the line1 i.e., the word "Transition-Guard"
				row1 >> transition_id; //Reading the next word/value i.e., the transition-number "0" (say)
				transition::ptr trans = transition::ptr(new transition()) ;
				trans->setTransId(transition_id);	//Note transition-id may start with 0, which does not have issue with dReach
				trans->setLabel(label);
				trans->setSourceLocationId(i);//i equals mode-id Note: here First Transition will go to the first Mode, 2nd with the 2nd Mode.
				trans->setDestinationLocationId(i+1);//Note here First Transition will go to the first Mode, 2nd with the 2nd Mode.
				//cout<<"Transition Label is "<< trans->getLabel()<<endl;

				std::list<std::string> guard;
				std::getline(in, line1);	//This read the polynomial-guard constraints "with equal to 0"
				guard.push_back(line1);
				//cout<<"Transition Guard line1 is "<< line1<<endl;
				trans->setGuard(guard);

				// ************* Working for the Modified Guard to support inequality *************
				std::list<std::string> guard_modified;
				//****** whether forward or backward is decided by if (Initial-location-ID == src-ID) then transition is forward(<=). even better use the hyperplane_to_halfspace function
				/*if (trans->getSourceLocationId() == init_id) {
					guard_modified = modify_guard(guard, 1);
				} else {
					guard_modified = modify_guard(guard, 2);
				}
				trans->setGuardModified(guard_modified);*/
				// ************* *************
				guard_modified = modify_guard_asRange(guard, epsilon);	//The range is -epsilon to +epsilon; which means 2*epsilon gap
				trans->setGuardModified(guard_modified); //Best is to convert "equality to a range by +/- epsilon value"

				list<transition::ptr> trans_list;
				trans_list.push_back(trans);
				//Note here First Transition will go to the first Mode, 2nd with the 2nd Mode.
				my_location = map_location_list1[i];	//i here is the mode-id
				//H->getLocation(transition_id)->setOutGoingTransitions(trans_list);//I hope this updates the transition of the location in the hybrid automata. NO THIS WAY UPDATE DID NOT WORK.
				my_location->setOutGoingTransitions(trans_list);	//the location is not updated with out-going-transition
				map_location_list2[i] = my_location;

			}

			if (tot_modes==3) {
				/*
				 Steps for handling Transitions:
				 (1) Read all transition from the learned model-file.
				 (2) Store these (2) transitions as forward[0] and forward[1]
				 (3) Now, create backward transitions as backward[0] and backward[1]
				 (4) Now, sequentially read the forward and backward transitions and push them to the corresponding modes.
				 * */
				std::getline(in, line1);	//This read for reading the Transition-Guard-number
				std::istringstream row1(line1);
				//cout<<"Transition Line is "<< line1<<endl;

				row1 >> label; //Reading First word of the line1 i.e., the word "Transition-Guard"
				row1 >> transition_id; //Reading the next word/value i.e., the transition-number "0" (say)
				transition::ptr trans = transition::ptr(new transition()) ;
				transition::ptr trans2 = transition::ptr(new transition()) ;

				trans->setTransId(transition_id);	//Note transition-id may start with 0, which does not have issue with dReach
				trans->setLabel(label);

				unsigned int src, dest;
				std::getline(in, line1);	//This read for reading the Src => Dest
				//cout <<"Trans Line="<<line1<<endl;
				std::istringstream row2(line1);
				row2 >> label_extra; //Reading First word of the line1 i.e., the word "Transition-Src-Dest"
				//cout<<"Transition Src-Dest Label is "<< label<<endl;
				row2 >> src; //Reading the next word/value i.e., the Src-mode-id "1" (say)
				//cout<<"Src = "<<src<<endl;
				row2 >> label_symbol; //Reading First word of the line1 i.e., the word " => "
				//cout<<"Transition Arrow Label is "<< label<<endl;
				row2 >> dest; //Reading the next word/value i.e., the Dest-mode-id "2".
				//cout<<"Dest-1 = "<<dest<<endl;

				if (i==1) { //1st transition has "syntax:   1 => 2 , 3
					//Although dest can be  2 , 3 but only 2 is/was taken. TODO (need to understand)
					row2 >> label_symbol; //Reading First word of the line1 i.e., the word " , "
					//cout<<"should be , = " << label_symbol <<endl;
					row2 >> dest2; //Reading the next word/value i.e., the Dest-mode-id "3".
					//cout<<"Dest-2 = "<<dest2<<endl;
				}

				trans->setSourceLocationId(src);
				trans->setDestinationLocationId(dest);
				//cout<<"Transition Src "<< trans->getSourceLocationId()<<endl;
				//cout<<"Transition Dest "<< trans->getDestinationLocationId()<<endl;

				std::list<std::string> guard;
				std::getline(in, line1);	//This read for reading the polynomial-guard constraints
				guard.push_back(line1);
				//cout<<"Transition Guard line1 is "<< line1<<endl;
				trans->setGuard(guard);
				transition_count++;

				// ************* Working for the Modified Guard to support inequality *************
				std::list<std::string> guard_modified;
				//guard_modified = modify_guard(guard, 1); //Reactivating
				if (i==1)
					guard_modified = modify_guard_forNonDeterminism(guard, epsilon, 1);		//converting to range as inequality and Anding with randomization. sign can be 1 (>=0) or 2 (<0)
				else
					guard_modified = modify_guard_asRange(guard, epsilon);		//converting to range as inequality

				trans->setGuardModified(guard_modified);
				// ************* *************

				//forward[i-1] = trans;	//vector indexing from 0 for C++
				forward[transition_count - 1] = trans;	//vector indexing from 0 for C++

				if (i==1) { //1st transition has "syntax:   1 => 2 , 3

					int id2 = tot_transitions + new_transition_Id;	//Giving new transition-Id
					new_transition_Id++;
					trans2->setTransId(id2);	//Note transition-id may start with 0, which does not have issue with dReach
					trans2->setLabel(label);

					trans2->setSourceLocationId(src);
					trans2->setDestinationLocationId(dest2);
					transition_count++;
					trans2->setGuard(guard);

					// ************* Working for the Modified Guard to support inequality *************
					guard_modified = modify_guard_forNonDeterminism(guard, epsilon, 2);		//converting to range as inequality and Anding with randomization. sign can be 1 (>=0) or 2 (<0)
					trans2->setGuardModified(guard_modified);	//same modification converting to range as inequality
					// ************* *************
					forward[transition_count - 1] = trans2;	//vector indexing from 0 for C++
				}

				// For SNDS (switched nonlinear dynamical systems) transition are bi-directional since the state space is divided
				transition::ptr back_trans = transition::ptr(new transition());

				int id = tot_transitions + new_transition_Id;	//Giving new transition-Id
				back_trans->setTransId(id);	//Note transition-id may start with 0, which does not have issue with dReach
				std::string back_trans_label = trans->getLabel();
				back_trans_label.append("-back");
				back_trans->setLabel(back_trans_label);
				new_transition_Id++;

				back_trans->setSourceLocationId(dest);
				back_trans->setDestinationLocationId(src);
				back_trans->setGuard(guard);
				trans_back_count++;

				// ************* Working for the Modified Guard to support inequality *************
				std::list<std::string> guard_modified_back;
				//guard_modified_back = modify_guard(guard, 2);	//This is the backward transition (so use >= guard). Argument value 1 for <= and 2 for >=

				guard_modified_back = modify_guard_asRange(guard, epsilon);

				back_trans->setGuardModified(guard_modified_back);
				// ************* *************

				//backward[i-1] = back_trans;	//vector indexing from 0 for C++
				backward[trans_back_count - 1] = back_trans;	//vector indexing from 0 for C++

				if (i==1) { //1st transition has "syntax:   1 => 2 , 3
					transition::ptr back_trans2 = transition::ptr(new transition());
					int id2_back = tot_transitions + new_transition_Id;	//Giving new transition-Id
					new_transition_Id++;

					back_trans2->setTransId(id2_back);	//Note transition-id may start with 0, which does not have issue with dReach
					std::string back_trans_label2 = trans2->getLabel();
					back_trans_label2.append("-back");
					back_trans2->setLabel(back_trans_label2);

					back_trans2->setSourceLocationId(dest2);
					back_trans2->setDestinationLocationId(src);
					back_trans2->setGuard(guard);
					trans_back_count++;

					// ************* Working for the Modified Guard to support inequality *************
					std::list<std::string> guard_modified_back;
					//guard_modified_back = modify_guard(guard, 2);	//This is the backward transition (so use >= guard). Argument value 1 for <= and 2 for >=

					guard_modified_back = modify_guard_asRange(guard, epsilon);
					back_trans2->setGuardModified(guard_modified_back);
					// ************* *************
					backward[trans_back_count - 1] = back_trans2;	//vector indexing from 0 for C++
				}
				//*********** forward and backward transitions creation done ******************************
			} //When mode==3
		} //End of reading all Transition

		//cout<<"Total number of Locations ="<<H->getTotalLocations() <<endl;
		if (tot_modes == 2) {
			//This section to get create a Backward Transition
			//cout<<"Total number of Locations = 2"<<endl;
			location::ptr previous_location = location::ptr(new location());
			list<transition::ptr> previous_trans_list, next_trans_list;// = transition::ptr(new transition()) ;
			previous_location = map_location_list1[1];	//Location's ID starts from 1. TODO use previous_loc_id
			previous_trans_list = previous_location->getOutGoingTransitions();

			transition::ptr back_transition = transition::ptr (new transition());
			transition::ptr previous_trans = transition::ptr (new transition());
			list<transition::ptr>::iterator it_trans = previous_trans_list.begin();
			previous_trans =  (*it_trans);

			std::string back_trans_label = "";
			back_trans_label.append(previous_trans->getLabel().c_str());
			back_trans_label.append("-back");
			back_transition->setLabel(back_trans_label);

			int id = tot_transitions;	//Giving new transition-Id (which is 1)
			back_transition->setTransId(id);
			back_transition->setSourceLocationId(2);	//Here 2 is the 2nd Mode, which is now the source.
			back_transition->setDestinationLocationId(1);	//Here 1 is the 1st Mode, which is the destination for back-transition.

			std::list<std::string> guard_list = previous_trans->getGuard();
			//std::list<std::string>::iterator it_guard = guard_list.begin();
			back_transition->setGuard(guard_list);

			// ************* Working for the Modified Guard to support inequality *************
			std::list<std::string> guard_modified_back;

			//****** whether forward or backward is decided by if (Initial-location-ID == src-ID) then transition is forward(<=)
			/*if (back_transition->getSourceLocationId() == init_id) {
				guard_modified_back = modify_guard(guard_list, 1);
			} else {
				guard_modified_back = modify_guard(guard_list, 2);
			}
			back_transition->setGuardModified(guard_modified_back);*/
			// ************* *************

			guard_modified_back = modify_guard_asRange(guard_list, epsilon);	//The range is -epsilon to +epsilon; which means 2*epsilon gap
			back_transition->setGuardModified(guard_modified_back); //Best is to convert "equality to a range by +/- epsilon value"

			next_trans_list.push_back(back_transition);

			my_location = map_location_list1[2];	//last location
			my_location->setOutGoingTransitions(next_trans_list);

			map_location_list2[2] = my_location;	//Here no modification to my_location, since last location does not have transition

		}  else if (tot_modes == 3) {

			std::map<int, location::ptr> list_locations;
			list_locations = H->getLocation_List();

			//Iterate through all the modes get the mode-id and create list-of-Transitions and add as outGoingTransitions
			for (std::map<int, location::ptr>::iterator i= list_locations.begin(); i != list_locations.end(); i++) {
				location::ptr loc = (*i).second;	//since our location starts from 0
				//cout<<"Location Name: "<<loc->getName() <<"  ID: "<< loc->getLocId()<<endl;
				unsigned int src = loc->getLocId();
				list<transition::ptr> trans = getAllTrans(src, forward, backward);

				my_location = map_location_list1[src];	//i here is the mode-id
				//H->getLocation(transition_id)->setOutGoingTransitions(trans_list);//I hope this updates the transition of the location in the hybrid automata. NO THIS WAY UPDATE DID NOT WORK.
				my_location->setOutGoingTransitions(trans);	//the location is not updated with out-going-transition
				map_location_list2[src] = my_location;

			}

			//cout<<"back_trans_ created="<<endl;
		} else if (tot_modes > 3) {
			std::cout << "\nMissing implementation for Mode/Location > 3!!!" << std::endl;
//			if (log_set){
//				log_file << "\nMissing implementation for Mode/Location > 3!!!" << std::endl;
//			}
			throw(new exception());
		}
		if (tot_modes > 1) { //Modification of Transition is required only for modes > 1
			//cout<<"Total number of Locations (2) ="<<H->getTotalLocations() <<endl;
			H->addMapped_Locations_List(map_location_list2);	//This line is important to update the transitions
		}

		//*********** Adding the variable to index mapping in the Automata ***********
		//Get any one of the Location and traverse through the flow_equation and get the LHS of the ODE
		location::ptr loc1 = location::ptr(new location());
		loc1 = map_location_list1[1];	//First location; can also use map_location_list2 or H->getLocation(1)
		list<flow_equation> ode = loc1->getDerivatives();
		int counter=0;
		for (list<flow_equation>::iterator it_ode = ode.begin(); it_ode != ode.end(); it_ode++) {
			string variableName = (*it_ode).varName;	//eg x0'
			size_t pos = variableName.find("'");
			variableName = variableName.substr(0, pos);	//extract only the variable name and not the derivative symbol
			H->insert_to_map(variableName, counter);
			counter++;
		}
		assert(tot_dimension==counter);	//total dimensions should be equal to this number of variables denoted by counter
/*

		//Reading and setting the Initial ID
		std::getline(in, line1);	//This read is for reading the Initial-Location-ID
		std::istringstream row2(line1);
		//cout<<"Transition Line is "<< line1<<endl;
		string init_label;
		unsigned int init_id;
		row2 >> init_label; //Reading First word of the line1 i.e., the word "Initial-mode"
		row2 >> init_id; //Reading the next word/value i.e., the Initial-Location-ID "1" (say)
		H->setInitialId(init_id);
*/

	} else {
		std::cout << "\nModel file not found, verify if the Learning algorithm worked!!!" << std::endl;
//		if (log_set){
//			log_file << "\nModel file not found, verify if the Learning algorithm worked!!!" << std::endl;
//		}
		throw(new exception());
	}
	cout << "Hybrid Automata Object Created ..."<<endl;
//	if (log_set){
//		log_file << "Hybrid Automata Object Created ..."<<endl;
//	}

	in.close();	//closing the file
}

//This model-parser function will replace the above two parsing functions
void ha_model_parser(hybridAutomata::ptr &H, user_inputs::ptr &user, intermediateResult::ptr &intermediate) {
	/*
	 * In this approach the learning algorithm creates transitions based on the connecting points and/or user-annotation between two modes.
	 * Thus, unlike the above two approaches i.e., one versus one and one versus rest where transitions depends on the number of modes is not the case here.
	 */
	//Has ODE parsing as common code


	string eng_selected = user->getEngine();
	unsigned int modifyGuard = 1;	//modify by default for bbc
	if (eng_selected=="txt2slx") {
		user->setOutputFilename(user->getModelFilename());
		modifyGuard = user->getGuard();
	} else if  (eng_selected=="learn-ha") {
		modifyGuard = user->getGuard();
	} else {	//This block is for engine = "bbc" and engine = "learn-ha-loop"
		//******** Temporary Fix: copying the file generated by learning algorithm to the current directory **********
		string copycommand ="";
		copycommand.append("cp ");
		copycommand.append(intermediate->getToolRootPath());
		//copycommand.append("/src/pwa/");	// ---> OLD implementation
		copycommand.append("/src/learnHA/");	// ---> NEW implementation
		copycommand.append(user->getOutputFilename());
		copycommand.append(" .");	//to the current working directory, i.e. in the build or Release or Debug directory
		int x = system(copycommand.c_str());
		if (x == -1) {
			cout << "Error executing cmd: " << copycommand << endl;
		}
	}
	//******** modelfile now in the current directory **********
	/*
	 * Note:
	 * This modelfile has a specific format generated by the learning algorithm. The syntax and format is as follows:
	 * First line contains File-parameter-information (number-of-modes, number-of-dimension and number-of-transitions)
	 * ---------------------------------------------------------------------------
	 * The SECOND line has the initial starting location-ID as: Example:  Initial-mode 1
	 * ---------------------------------------------------------------------------
	 * Third line onwards contains the mode number-1
	 * Forth line contains the word "inv:"
	 * Fifth line contains the invariant expression
	 * Sixth line contains the word "ODE:"
	 * Seventh line the ODE for this mode for the first variable
	 * Eighth line the ODE for the 2nd variable (assume number-of-dimension=2)
	 * ---------------------------------------------------------------------------
	 * Ninth line contains the mode number-2
	 * Tenth line contains the word "inv:"
	 * Eleventh line contains the invariant expression
	 * Twelfth line contains the word "ODE:"
	 * Thirteenth line contains the ODE for this mode for the first variable
	 * Fourteenth line the ODE for the 2nd variable (assume number-of-dimension=2)
	 * ---------------------------------------------------------------------------

	 * Fifteenth line contain the Transition-Guard number-1
	 * Sixteenth line will contain Transition-Src-Dest	"src-id  =>  dest-id" Example: Transition-Src-Dest	1  =>  2
	 * Seventeenth line will contain the word "guard:"
	 * Eighteenth line will contain the polynomial-guard constraints
	 * Nineteenth line will contain the word "reset:"
	 * Twentieth line onward will contain the reset equation for each variable
	 * .... and so on.
	 *
	 * */


	const char* modelfile = user->getOutputFilename().c_str();		//This is the optimized fileName
//	std::cout <<" File name = " << modelfile << std::endl;
	std::ifstream in(modelfile);//This is the file generated by running the Learning Algorithm
	unsigned int tot_modes, tot_dimension, tot_transitions;

	if (in) {
		std::string line1;
		std::getline(in, line1); //Reading First Line: Each getline() function will read a line and moves the pointer to the beginning of the next line
		std::istringstream rowInitial(line1);
		//cout<<"Line is "<< line1<<endl;
		rowInitial >> tot_modes; //Reading First value the number-of-modes
		rowInitial >> tot_dimension; //Reading Second value the number-of-dimension
		rowInitial >> tot_transitions; //Reading Third value the number-of-transition-guard

		//cout << "tot_modes = "<<tot_modes<<"  tot_dim="<<tot_dimension <<"   tot_trans="<<tot_transitions <<endl;

		//Shifting the code for Initial Location-ID from the last line to the SECOND line.
		//Reading and setting the Initial ID
		std::getline(in, line1);	//This read is for reading the Initial-Location-ID
		std::istringstream row22(line1);
		//cout<<"Transition Line is "<< line1<<endl;
		string init_label;
		unsigned int init_id;
		row22 >> init_label; //Reading First word of the line1 i.e., the word "Initial-mode"
		row22 >> init_id; //Reading the next word/value i.e., the Initial-Location-ID "1" (say)
		H->setInitialId(init_id);

		//cout <<"Initial Location-ID=" << init_id <<endl;

		std::map<int, location::ptr> map_location_list1, map_location_list2; //mapping of the key loc_id to location::ptr
		//std::map<std::string, int> loc_name_map_id; //here name is used as a Key for ease of search
		//int loc_counter = 1; //loc-Id for key to map_loc_list
		//Reading All Mode's Invariant and ODE
		for (unsigned int i = 1; i <= tot_modes; i++) {	//Modes starts from 1
			location::ptr loc = location::ptr(new location());
			string label_modes;
			int mode_number;

			getline(in , line1);	//This read for reading the mode number
			std::istringstream row1(line1);
//			cout<<"Line is "<< line1<<endl;
			row1 >> label_modes; //Reading First word of the line1 i.e., the word "mode"
			row1 >> mode_number; //Reading the next word/value i.e., the mode-number "1" (say)
			string mode_name = "mode"+ to_string(mode_number);
			loc->setLocId(mode_number);
			loc->setName(mode_name);


			// ******** Reading Mode Invariant **************
			//   simplified the invariant as a single string of expression. Better parsing and printing from learning-algo can be done later.
			getline(in , line1);	//This read for reading the word "inv:"
			std::istringstream row2(line1);
//			std::cout<<"Line is "<< line1<<endl;
			std::string word_inv;
			row2 >> word_inv; //Reading the entire invariant expression
//			std::cout<<"Word inv is "<< word_inv<<endl;

			getline(in , line1);	//This read for reading the invariant expression
			std::istringstream rowInv(line1);
//			std::string mode_inv_str;
//			rowInv >> mode_inv_str; //Reading the invariant expression
			std::list<std::string> list_inv;
			//list_inv.push_back(mode_inv_str);
			list_inv = string2list(line1);	//converting the entire inv expression into list of expression
			//list_inv.push_back(lst_inv);
			loc->setInvariant(list_inv);

			// ***********************************************


			// ******** Reading Mode ODE **************
			getline(in , line1);	//This read for reading the word "ODE:"
			std::istringstream row3(line1);
			std::string word_ode;
			row3 >> word_ode; //Reading the entire invariant expression
//			std::cout<<"Word ODE is "<< word_ode<<endl;

			list<flow_equation> derivatives;

			for (unsigned int j = 0; j < tot_dimension; j++) {
				flow_equation ODEperVariable;
				string LHS, RHS;
				getline(in , line1);	//This read for reading the ODE for each dimension
				ODEperVariable.derivative = line1;
				std::istringstream lhsWord(line1);
				lhsWord >> ODEperVariable.varName; //Note it include the derivative symbol (')
//				cout <<"ODE line " << line1 <<endl;
				size_t found = line1.find("=");
				if (found != string::npos) {
					//cout << "First occurrence is " << found << endl;
					//RHS = line1.substr (found+1);
					//ODEperVariable.RHSexpression = boost::trim_left(RHS);	//can think about constant dynamics later
					RHS = line1.substr (found+2); //Also left triming a white space
					ODEperVariable.RHSexpression = RHS;	//can think about constant dynamics later
					//cout << RHS << endl;
				} else {
					cout << "Invalid ODE equation found! " << endl;
					throw(new exception());
				}
				derivatives.push_back(ODEperVariable);
			}
			loc->setDerivatives(derivatives);	//First add all the modes without transition and later update the transition.
			map_location_list1[loc->getLocId()] = loc;
			//H->addLocation(loc);

			// ***********************************************
		}
		H->addMapped_Locations_List(map_location_list1);

		location::ptr my_location = location::ptr(new location());
		//my_location = map_location_list1[loc_id];	//accessing from the map data structure to create a new location with same ID and name
		//and fill up the remaining details and replace the hybrid_automata with this new detailed location


		// ******** Reading Transitions **************
		// each transition, has ID, srd: => dest: , guard:, guard expr, word reset:, reset expressions for each variable. Here there is no forward and backward trans

		double epsilon= user->getPrecisionGuardRange();

		//Reading All Transition-Guard:
		//std::vector<transition::ptr> forward(2);	//for mode m==3, we have 3 transitions, K = m * (m - 1)/2
		std::list<transition::ptr> all_transitions;
		unsigned int new_transition_Id = 1;


		for (unsigned int i = 1; i <= tot_transitions; i++) {	//Modes starts from 1

			string label, label_symbol, label_extra;
			int transition_id;


			transition::ptr trans = transition::ptr(new transition());
			string label_trans;
			unsigned int trans_number;

			getline(in , line1);	//This read for reading the transition number
			std::istringstream row1(line1);
			row1 >> label_trans; //Reading First word of the line1 i.e., the word "Transition-ID"
			row1 >> trans_number; //Reading the next word/value i.e., the Transition-number "1" (say)
			string trans_name = "trans"+ to_string(trans_number);
			trans->setTransId(trans_number);
			trans->setLabel(trans_name);

			unsigned int src, dest;
			std::getline(in, line1);	//This read for reading the word example: "Trans-Src-Dest 1 => 2"
			//cout <<"Trans Line="<<line1<<endl;
			std::istringstream row2(line1);
			row2 >> label_extra; //Reading First word of the line1 i.e., the word "Transition-Src-Dest"
			//cout<<"Transition Src-Dest Label is "<< label<<endl;
			row2 >> src; //Reading the next word/value i.e., the Src-mode-id "1" (say)
			//cout<<"Src = "<<src<<endl;
			row2 >> label_symbol; //Reading First word of the line1 i.e., the word " => "
			//cout<<"Transition Arrow Label is "<< label<<endl;
			row2 >> dest; //Reading the next word/value i.e., the Dest-mode-id "2".
			//cout<<"Dest-1 = "<<dest<<endl;

			trans->setSourceLocationId(src);
			trans->setDestinationLocationId(dest);
			//cout<<"Transition Src "<< trans->getSourceLocationId()<<endl;
			//cout<<"Transition Dest "<< trans->getDestinationLocationId()<<endl;


			// ******** Reading Transition-guard **************

			std::getline(in, line1);	//This read for reading the word "guard:"
			//cout <<"Trans Line="<<line1<<endl;
			std::istringstream row3(line1);
			row3 >> label_extra;
//			cout<<"word guard = " << label_extra <<endl;

			std::list<std::string> guard;
			std::getline(in, line1);	//This read for reading the polynomial-guard constraints
			guard.push_back(line1);
			//cout<<"Transition Guard line1 is "<< line1<<endl;
			trans->setGuard(guard);

			// ** Working for the Modified Guard to support inequality **
			std::list<std::string> guard_modified;

			if (modifyGuard == 0) { //user decided not to modify guard
				//trans->setGuardModified(guard);

				//cout <<"guard = " << (*trans->getGuardModified().begin()) <<endl;
				//check if user input "=" then modify to "==" to support Matlab's simulink syntax. This is done only when user decide not to modify guard.
				// Since the correct input symbol in the guard equation is "=" in the model file. But in matlab simulink the correct symbol is "==".
				std::list<std::string> correct_guard;
				correct_guard = correctGuard(line1);
				trans->setGuardModified(correct_guard);
				//cout <<"guard = " << (*trans->getGuardModified().begin()) <<endl;

			} else {	// modify gurad to inequality

				//guard_modified = modify_guard_asRange(guard, epsilon);		//converting to range as inequality. Working with epsilon ERROR

				//Trying to modify guard into halfspace instead of inequality-with-range from hyperplane.
				//Practical observation showed data having src(+1) => dest(-1); gives guard-condition <= 0
				guard_modified = modify_guard_asHalfspace(guard, epsilon);		//converting " = 0" to "<= epsilon". Decision based on SVM's output observation

				trans->setGuardModified(guard_modified);
			}
			// ***********************************************

			// ******** Reading Transition-Reset **************

			std::getline(in, line1);	//This read for reading the word "Reset:"
			//cout <<"Trans Line="<<line1<<endl;
			std::istringstream row4(line1);
			row4 >> label_extra;
//			cout<<"word reset = " << label_extra <<endl;

			std::list<reset_equation> list_reset;

			for (unsigned int j = 0; j < tot_dimension; j++) {
				reset_equation reset_per_variable;
				string LHS, RHS;
				getline(in , line1);	//This read for reading the reset for each dimension
				reset_per_variable.reset_expression = line1;
				std::istringstream lhsWord(line1);
				lhsWord >> reset_per_variable.varName; //Note it include the prime symbol (')

				size_t found = line1.find("=");
				if (found != string::npos) {
					RHS = line1.substr (found+2); //Also left triming a white space
					reset_per_variable.RHSexpression = RHS;	//can think about constant dynamics later
					//cout << RHS << endl;
				} else {
					cout << "Invalid Reset equation found! " << endl;
					throw(new exception());
				}
				list_reset.push_back(reset_per_variable);
			}
			trans->setAssignment(list_reset);

			// ***********************************************


			all_transitions.push_back(trans);//collecting all the transitions together
		} //End of reading all transitions


		if (tot_modes >= 1 && all_transitions.size() >= 1) {

			std::map<int, location::ptr> list_locations;
			list_locations = H->getLocation_List();

			//Iterate through all the modes get the mode-id and create list-of-Transitions and add as outGoingTransitions
			for (std::map<int, location::ptr>::iterator i= list_locations.begin(); i != list_locations.end(); i++) {
				location::ptr loc = (*i).second;	//since our location starts from 0
				//cout<<"Location Name: "<<loc->getName() <<"  ID: "<< loc->getLocId()<<endl;
				unsigned int src = loc->getLocId();
				list<transition::ptr> trans = getAllTrans(src, all_transitions);

				my_location = map_location_list1[src];	//i here is the mode-id
				my_location->setOutGoingTransitions(trans);	//the location is now updated with out-going-transition
				map_location_list2[src] = my_location;

			}
			//cout<<"back_trans_ created="<<endl;
		}

		if (tot_modes >= 1 && all_transitions.size() >= 1) { //Modification of Transition is required only for modes > 1
			//cout<<"Total number of Locations (2) ="<<H->getTotalLocations() <<endl;
			H->addMapped_Locations_List(map_location_list2);	//This line is important to update the transitions
		}

		// ***********************************************


	} else {  //end of reading the file
		std::cout << "\nModel file not found, verify if the Learning algorithm worked!!!" << std::endl;
		throw(new exception());
	}
	//cout << "Hybrid Automata Object Created ..."<<endl;

	in.close();	//closing the file

}

// Replaces the expression containing "=" into "==", also returns as a list of expression
std::list<std::string> correctGuard(std::string line1){

	//string line1="x0 >= 0.344648094532294";
	//string line1="x0 >= 0.344648094532294 && x0 = 60.7002 && x1 >= 905.32532 && x1 = 1093.212";
	typedef boost::tokenizer<boost::char_separator<char> > tokenizer;
	boost::char_separator<char> sep("&");
	tokenizer tokens(line1, sep);
	int index = 0;
	list<string> each_guard;
	for (tokenizer::iterator tok_iter = tokens.begin();	tok_iter != tokens.end(); ++tok_iter) {
		string ss = (std::string)(*tok_iter);
		boost::trim(ss);
		each_guard.push_back(ss);
	}


	for (list<string>::iterator it=each_guard.begin(); it != each_guard.end(); it++){
		std::string & the_guard(*it);	//reference
		//cout <<"the_guard:" << the_guard <<endl;
		boost::char_separator<char> sep1(" ");
		tokenizer tokens1(the_guard, sep1);
		unsigned int found=0;
		for (tokenizer::iterator tok_iter1 = tokens1.begin(); tok_iter1 != tokens1.end(); ++tok_iter1) {
			//cout << (*tok_iter1) << endl;
			if ((*tok_iter1) == "="){
				//cout <<"found = sign" <<endl;
				found=1;
			}
		}
		if (found) {
			unsigned int pos = the_guard.find("=");
			string  replacestr1="==";
			//cout <<"token before: " <<(*it) << "  the_guard:" << the_guard << endl;
			the_guard.replace(pos, 1, replacestr1);
			//cout <<"token after: " <<(*it) << "  the_guard:" << the_guard << endl;
		}
	}

	return each_guard;
}


//Take a list<string> of guard and returns list<string> of modified guard and argument a double epsilon value
//Assuming the list of string has only a single string and not a list. TODO: if the guard is not a polynomial equation
std::list<std::string> modify_guard_asRange(std::list<std::string> guard, double epsilon) {
	std::list<std::string> changed_guard;
	///Assuming that the guard is of the form ax+by = 0   Note: THE blank space before and after the zero on the RHS.

	for (std::list<std::string>::iterator gd = guard.begin(); gd != guard.end(); gd++) {
		string str = (*gd);
		std::string search_key (" = ");
		unsigned int guard_length = str.size();
		std::size_t found = str.rfind(&search_key[0], guard_length, 3);	//searching from reverse so position is guard_length and match 3 characters from the search_key in the str

		if (found != std::string::npos) {

		    string str1=str, str2=str, replacestr1=" >= "+to_string(-1 * epsilon)+" + ", replacestr2=" <= "+to_string(epsilon)+" + ";

			str1.replace(found, search_key.length(), replacestr1);
			changed_guard.push_back(str1);

			str2.replace(found, search_key.length(), replacestr2);
			changed_guard.push_back(str2);
		} else { // operator " = " not found so just keep the guard as it is
			changed_guard.push_back(str);
		}

		/*unsigned int pos = str.find("=");
		string str1=str, str2=str, replacestr1=">= "+to_string(-1 * epsilon)+" + ", replacestr2="<= "+to_string(epsilon)+" + ";
		str1.replace(pos, 1, replacestr1);
		changed_guard.push_back(str1);

		str2.replace(pos, 1, replacestr2);
		changed_guard.push_back(str2);*/
	}



	return changed_guard;
}

//Takes a string of guard with "=" symbol and convert it into "<=". This decision is made due to the SVM's output observation
std::list<std::string> modify_guard_asHalfspace(std::list<std::string> guard, double epsilon) {
	std::list<std::string> changed_guard;
	///Assuming that the guard is of the form ax+by = 0   Note: THE blank space before and after the zero on the RHS.

	for (std::list<std::string>::iterator gd = guard.begin(); gd != guard.end(); gd++) {
		string str = (*gd);
		std::string search_key (" = ");
		unsigned int guard_length = str.size();
		std::size_t found = str.rfind(&search_key[0], guard_length, 3);	//searching from reverse so position is guard_length and match 3 characters from the search_key in the str

		if (found != std::string::npos) {

			string str2=str, replacestr2=" <= "+to_string(epsilon)+" + ";
			str2.replace(found, search_key.length(), replacestr2);
			changed_guard.push_back(str2);
		} else { // operator " = " not found so just keep the guard as it is
			changed_guard.push_back(str);
		}
	}

	return changed_guard;
}

//Take a list<string> of guard and returns list<string> of modified guard as epsilon-range value Also ANDing with randomization for non-deterministic transitions
std::list<std::string> modify_guard_forNonDeterminism(std::list<std::string> guard, double epsilon, unsigned int sign) {
	std::list<std::string> changed_guard;
	///Assuming that the guard is of the form ax+by = 0   Note: RHS is 0

	std::list<std::string>::iterator gd = guard.begin();
	string str = (*gd);
	unsigned int pos = str.find("=");
	/*if (less_or_greater == 1)
		str.replace(pos, 1, "<=");
	else if (less_or_greater == 2)
		str.replace(pos, 1, ">=");*/

	string str1=str, str2=str, replacestr1=">= "+to_string(-1 * epsilon)+" + ", replacestr2="<= "+to_string(epsilon)+" + ";
	string str3="";

	str1.replace(pos, 1, replacestr1);
	changed_guard.push_back(str1);

	str2.replace(pos, 1, replacestr2);
	changed_guard.push_back(str2);
	if (sign == 1) //1 for >= 0   and   2 for < 0
		str3 = " myRandomOut() >= 0";
	else
		str3 = " myRandomOut() < 0";
	changed_guard.push_back(str3);

	return changed_guard;
}




//Take a list<string> of guard and returns list<string> of modified guard and argument less_than_equal=1 and greater_than_equal=2
//Assuming the list of string has only a single string and not a list. TODO: if the guard is not a polynomial equation
std::list<std::string> modify_guard(std::list<std::string> gurad, unsigned int less_or_greater) {
	std::list<std::string> changed_guard;

	std::list<std::string>::iterator gd = gurad.begin();
	string str = (*gd);
	unsigned int pos = str.find("=");
	if (less_or_greater == 1)
		str.replace(pos, 1, "<=");
	else if (less_or_greater == 2)
		str.replace(pos, 1, ">=");

	changed_guard.push_back(str);

	return changed_guard;
}


list<transition::ptr> getAllTrans(unsigned int src, std::vector<transition::ptr> forward, std::vector<transition::ptr> backward) {
	list<transition::ptr> trans;
	for (unsigned int i=0; i<forward.size(); i++) {
		if (src == forward[i]->getSourceLocationId()) {
			trans.push_back(forward[i]);
		}
	}
	for (unsigned int i=0; i<backward.size(); i++) {
		if (src==backward[i]->getSourceLocationId()){
			trans.push_back(backward[i]);
		}
	}
	return trans;
}

list<transition::ptr> getAllTrans(unsigned int src, list<transition::ptr>& all_trans) {
	list<transition::ptr> sublist_trans;
	transition::ptr this_trans;

	for (list<transition::ptr>::iterator it=all_trans.begin(); it != all_trans.end(); it++) {
		if (src == (*it)->getSourceLocationId()) {
			this_trans = (*it);
			sublist_trans.push_back(this_trans);
		}
	}

	return sublist_trans;
}


//Function for Debugging the output of HA
void verifyHA_output(hybridAutomata::ptr &H) {


	cout << "*********Verify HA Output*********"<<endl;
	cout << "Total number of Locations = "<< H->getTotalLocations()<<endl;


	H->print_var_mapping();

	cout<< "Initial Location ID: "<< H->getInitialId() <<endl;

	std::map<int, location::ptr> list_locations;
	list_locations = H->getLocation_List();

	for (std::map<int, location::ptr>::iterator i= list_locations.begin(); i != list_locations.end(); i++) {
		location::ptr loc = (*i).second;	//since our location starts from 0
		cout <<"\n======****** Mode Details ******======"<<endl;
		cout << "Location Name: "<<loc->getName() <<"  ID: "<< loc->getLocId()<<endl;
		std::list<std::string> inv_test = loc->getInvariant();
		for (std::list<std::string>::iterator mod_inv = inv_test.begin(); mod_inv != inv_test.end(); mod_inv++){
			std::cout << "Invariant: " << (*mod_inv) << std::endl;
		}

		list<flow_equation> derivatives = loc->getDerivatives();

		for (list<flow_equation>::iterator it_flow = derivatives.begin(); it_flow != derivatives.end(); it_flow++) {
			std::cout << "Flow: "<<(*it_flow).derivative<< std::endl;
			//cout<<"Flow:varName "<<(*it_flow).varName<<endl;
			//cout<<"Flow:RHS "<<(*it_flow).RHSexpression<<endl;
		}

		list<transition::ptr> trans = loc->getOutGoingTransitions();
		std::cout <<"====== Outgoing transition ======"<< std::endl;
		for (list<transition::ptr>::iterator it_trans = trans.begin(); it_trans != trans.end(); it_trans++) {
			std::cout <<"Transition ID: "<< (*it_trans)->getTransId()<< std::endl;
			std::cout <<"Transition Label: "<< (*it_trans)->getLabel()<< std::endl;
			std::cout <<"Transition Source-ID and Destination-ID:  "<< (*it_trans)->getSourceLocationId() << "  --->   "<< (*it_trans)->getDestinationLocationId()<< std::endl;


			std::list<std::string> guard = (*it_trans)->getGuard();
			list<std::string>::iterator it_guard = guard.begin();
			std::cout<< "Transition-Guard: "<< (*it_guard)<<endl;

			std::list<std::string> guard_modified = (*it_trans)->getGuardModified();
			string guard_changed = (*guard_modified.begin());
			std::cout<< "Transition-Modified Guard: " << std::endl;
			for (std::list<std::string>::iterator mod_guard=guard_modified.begin(); mod_guard != guard_modified.end(); mod_guard++){
				std::cout << (*mod_guard) << std::endl;
			}

			std::cout<< "Transition-Reset: "<< std::endl;
			list<reset_equation> reset_eqs = (*it_trans)->getAssignment();
			for (list<reset_equation>::iterator it_reset = reset_eqs.begin(); it_reset != reset_eqs.end(); it_reset++) {
				std::cout << "Reset: " << (*it_reset).reset_expression << std::endl;
				//cout<<"Reset: varName "<<(*it_reset).varName << endl;
				//cout<<"Reset: RHS "<<(*it_reset).RHSexpression << endl;
			}

		}//End of the Transition
	} //End of the Location

}


void modelConstruction(hybridAutomata::ptr &H, user_inputs::ptr &user, intermediateResult::ptr &intermediate, summary::ptr &report) {


//	extern  unsigned int log_set;
	/*std::ofstream log_file;
	log_file.open("bbc4cps_log_file.txt", ios::out | ios::app);*/
//	std::ofstream log_file("bbc4cps_log_file.txt",  std::ios_base::binary | std::ios_base::app);



	string outfile="";
	outfile=user->getOutputFilename();
	//*****************************************
	size_t found = outfile.find(".");	//extract file-name from extension
	if (found != string::npos) {
		outfile = outfile.substr (0,found);
	} //otherwise outfile remains as outfile

	intermediate->setOutputfilenameWithoutExtension(outfile);

	//cout<<"Creating outfile = "<<outfile <<endl;
	//Create a folder by the name and put the .drh model file inside it, so that all outputs from the dReach tool are in this folder
	string createCommand = "";
	createCommand.append("mkdir ");
	createCommand.append(outfile);
	int x = system(createCommand.c_str());
	if (x == -1) {
		std::cout <<"Error executing cmd: " << createCommand <<std::endl;
	}
	//*****************************************
	string file_with_path = "";
	file_with_path.append(outfile);	//this is the folder-name
	file_with_path.append("/");
	file_with_path.append(outfile);
	file_with_path.append(".drh");	//outfile.drh
	//*****************************************
	//cout<<"Creating file with path = "<<file_with_path <<endl;
	intermediate->setDReachModelFilenameWithPath(file_with_path);


	boost::timer::cpu_timer inputModelCreation;
	inputModelCreation.start();
	//************************************
	modelConstructor::ptr dreachModel = modelConstructor::ptr(new modelConstructor());
	ofstream modelfile;
	modelfile.open(file_with_path);
	if (modelfile.is_open()) {
		std::cout << "\nFile " << file_with_path << " created for Model-Checking using dReach Tool ...\n";
		modelfile << "//Constructing dReach Model-File from tool BBC4CPS";
		modelfile << "\n";
		dreachModel->printModelFile(H, modelfile, user);
	} else {
		std::cout << "Error opening file: " << file_with_path;
	}
	modelfile.close();
	//************************************
	inputModelCreation.stop();
	double wall_clock_modelParser;
	wall_clock_modelParser = inputModelCreation.elapsed().wall / 1000000; //convert nanoseconds to milliseconds
	double running_time = wall_clock_modelParser / (double) 1000;	//convert milliseconds to seconds
	//std::cout << "Model Parsing into Hybrid Automaton: Running Time (in Seconds) = " << running_time<<endl;
	report->setRuntimeInputModelConstruction(running_time);

	std::cout << "\n dReach input-model file created ...\n";
//	if (log_set){
//		log_file << "\n dReach input-model file created ...\n";
//	}
}

/*
 * separates the string into list of string, where separation is done based on "& "
 */
std::list<std::string> string2list(std::string input_str) {
	std::list<std::string> lst_string;
	//input_str="x0>=0.344648094532294 & x0<=60.7002246998343 & x1>=905.325240216932 & x1<=1093.21291463544";
	typedef boost::tokenizer<boost::char_separator<char> > tokenizer;
		boost::char_separator<char> sep("&");
		tokenizer tokens(input_str, sep);
		int index = 0;
		for (tokenizer::iterator tok_iter = tokens.begin();
				tok_iter != tokens.end(); ++tok_iter) {
			//std::cout << (*tok_iter) << endl;
			string ss = (std::string) (*tok_iter);
			boost::trim(ss);
			//std::cout << ss << endl;
			lst_string.push_back(ss);
		}
	return lst_string;
}




void readlastWord(){

	const char* runResultfile = "sys_generated_tempfile.txt";
	std::ifstream in(runResultfile); //This is the file generated from dReach output: For s sample see output file "modelChecker/sample_output_file.txt"
	std::string dReach_result;

	//Read all the lines the last word of the last line contain word SAT or unsat
	if (in) {
		while (!in.eof()) {
			std::string line1;
			std::getline(in, line1); //Reading First Line for total intermediate, input and output variables
			std::istringstream row1(line1);
			for ( ;row1 >> dReach_result; ) {
			 //Reading upto the last word
				std::cout <<"dReach-result = "<<dReach_result<<std::endl;
			}
		}
		std::cout <<"The last word is = "<<dReach_result<<std::endl;
	}

}
